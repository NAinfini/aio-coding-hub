#!/usr/bin/env bash
set -euo pipefail

repo_root="$(git rev-parse --show-toplevel)"
cd "$repo_root"

prettier_targets=()
rust_tauri_targets=()
has_src_changes=false
has_tauri_changes=false

while IFS= read -r file; do
  case "$file" in
    src/*)
      has_src_changes=true
      case "$file" in
        *.js|*.jsx|*.ts|*.tsx|*.css|*.scss|*.md|*.json|*.yaml|*.yml)
          prettier_targets+=("$file")
          ;;
      esac
      ;;
    src-tauri/*)
      has_tauri_changes=true
      case "$file" in
        *.rs)
          rust_tauri_targets+=("$file")
          ;;
      esac
      ;;
  esac
done < <(git diff --cached --name-only --diff-filter=ACMR)

if [ "$has_src_changes" = false ] && [ "$has_tauri_changes" = false ]; then
  echo "[pre-commit] No src/ or src-tauri/ changes, skipping checks."
  exit 0
fi

echo "[pre-commit] Auto-fixing formatting for staged files..."

# Avoid auto-fixing when files are partially staged, otherwise formatters may
# rewrite working tree content and break the user's intended staging.
partially_staged=()
if [ "${#prettier_targets[@]}" -gt 0 ] || [ "${#rust_tauri_targets[@]}" -gt 0 ]; then
  all_targets=("${prettier_targets[@]+"${prettier_targets[@]}"}" "${rust_tauri_targets[@]+"${rust_tauri_targets[@]}"}")
  for file in "${all_targets[@]}"; do
    if [ -n "$file" ] && ! git diff --quiet -- "$file"; then
      partially_staged+=("$file")
    fi
  done
fi

if [ "${#partially_staged[@]}" -gt 0 ]; then
  echo "[pre-commit] Detected partially staged files that need formatting:"
  for file in "${partially_staged[@]}"; do
    echo "  - $file"
  done
  echo "[pre-commit] Please stage those files completely (or stash unstaged hunks), then retry the commit."
  exit 1
fi

if [ "${#prettier_targets[@]}" -gt 0 ]; then
  pnpm exec prettier --write -- "${prettier_targets[@]}"
  git add -- "${prettier_targets[@]}"
fi

# `cargo fmt` formats the crate/workspace; we only run it when staged Rust files exist.
# After formatting, stage any changes under src-tauri so the commit matches what was checked.
if [ "${#rust_tauri_targets[@]}" -gt 0 ]; then
  (cd "src-tauri" && cargo fmt)
  git add -u -- "src-tauri"
fi

if [ "$has_src_changes" = true ]; then
  echo "[pre-commit] Running frontend checks..."
  pnpm run check:precommit:src
fi

if [ "$has_tauri_changes" = true ]; then
  echo "[pre-commit] Running Rust fast checks..."
  # 中文说明：当 src-tauri/Cargo.toml 发生变更但 Cargo.lock 未同步更新时，
  # cargo --locked 会直接失败，问题常常被拖到 pre-push 才暴露。
  # 这里在检测到典型报错后自动更新 Cargo.lock 并重新校验，减少反复踩坑。
  tauri_log="$(mktemp -t aio-precommit-tauri.XXXXXX)"
  if pnpm run check:precommit:tauri 2>&1 | tee "$tauri_log"; then
    rm -f "$tauri_log"
  else
    if grep -q "needs to be updated but --locked was passed" "$tauri_log"; then
      # Avoid auto-fixing when Cargo.lock is partially staged.
      if ! git diff --quiet -- "src-tauri/Cargo.lock"; then
        echo "[pre-commit] Detected unstaged changes in src-tauri/Cargo.lock."
        echo "[pre-commit] Please stage it completely (or stash unstaged hunks), then retry the commit."
        rm -f "$tauri_log"
        exit 1
      fi

      echo "[pre-commit] Cargo.lock is stale, attempting to update it (offline first)..."
      if (cd "src-tauri" && cargo check --offline); then
        true
      else
        (cd "src-tauri" && cargo check)
      fi
      git add -- "src-tauri/Cargo.lock"

      echo "[pre-commit] Re-running Rust fast checks with --locked..."
      pnpm run check:precommit:tauri
      rm -f "$tauri_log"
    else
      rm -f "$tauri_log"
      exit 1
    fi
  fi
fi
